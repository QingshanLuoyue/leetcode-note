## 唯一摩尔斯密码词

### 题目
> 国际摩尔斯密码定义一种标准编码方式<br>
> 将每个字母对应于一个由一系列点和短线组成的字符串<br>
> 比如: "a" 对应 ".-", "b" 对应 "-...", "c" 对应 "-.-.", 等等。

为了方便，所有26个英文字母对应摩尔斯密码表如下：

[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]

给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。

例如，"cab" 可以写成 "-.-..--..."，(即 "-.-." + "-..." + ".-"字符串的结合)。<br>
我们将这样一个连接过程称作单词翻译。

返回我们可以获得所有词不同单词翻译的数量。

<br>

### 示例
```
示例 1：

例如:
输入: words = ["gin", "zen", "gig", "msg"]
输出: 2
解释: 
各单词翻译如下:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

共有 2 种不同翻译, "--...-." 和 "--...--.".
```
>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/unique-morse-code-words<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

<br>

### 解题思路
普通方式
```javascript
定义变量数组 res = []
1、第一层循环遍历 `单词数组` 拿到 `单词元素 word`
2、
因为都是 `小写字母` ， `小写字母` 第一位 a 的数值编号是 97；
我们需要从 `摩斯数组` 中，取 a 以及其后的字母对应的摩斯码，就要使用字母的数值编号 - 97，得到摩斯数组中对应的下标
3、第二层循环遍历拿到的 `单词元素 word`，根据上面的计算逻辑，进行字母的摩斯码替换;
用一个变量 mosStr 拼接，得到该单词元素的 `摩斯码`
4、第二层循环结束后，使用变量 `数组 res` 存储上面得到的单词元素 `摩斯码` mosStr
5、将 mosStr 与 res 里面的元素进行对比，是否存在于 res 中，做去重处理
6、最后，返回 res 的长度
```

或

Set 集合去重
```javascript
定义集合 res = new Set()
1、第一层循环遍历 `单词数组` 拿到 `单词元素 word`
2、
因为都是 `小写字母` ， `小写字母` 第一位 a 的数值编号是 97；
我们需要从 `摩斯数组` 中，取 a 以及其后的字母对应的摩斯码，就要使用字母的数值编号 - 97，得到摩斯数组中对应的下标
3、第二层循环遍历拿到的 `单词元素 word`，根据上面的计算逻辑，进行字母的摩斯码替换;用一个变量 mosStr 拼接，得到该单词元素的 `摩斯码`
4、第二层循环结束后，使用 `集合 res` 存储上面得到的单词元素 `摩斯码` mosStr
5、因为集合唯一性的特性，确保每个元素都不重复，所以 res 的 size 就是最终的答案
```

<br>

### 题解

普通方式
```javascript
let uniqueMorseRepresentations = function(words) {
    let mos = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
    let res = []
    // 第一层循环遍历 `单词数组` 拿到 `单词元素 word`
    words.forEach(word => {
        let mosStr = ''
        for (let i = 0; i < word.length; i++) {
            // 因为都是 `小写字母` ， `小写字母` 第一位 a 的数值编号是 97；
            // 我们需要从 `摩斯数组` 中，取 a 以及其后的字母对应的摩斯码
            // 就要使用字母的数值编号 - 97，得到摩斯数组中对应的下标
            let strNum = word[i].charCodeAt()
            // 变量 mosStr 拼接，得到该单词元素的 `摩斯码`
            mosStr += mos[strNum - 97]
        }
        let judge = true
        for (let n = 0; n < res.length; n++) {
            // 将 mosStr 与 res 里面的元素进行对比，是否存在于 res 中，做去重处理
            if (res[n] === mosStr) {
                judge = false
                break;
            }
        }
        if (judge) {
            // `数组 res` 存储上面得到的单词元素 `摩斯码` mosStr
            res.push(mosStr)
        }
    })
    return res.length
};
```

或者

使用 Set 集合去重
```javascript
let uniqueMorseRepresentations = function(words) {
    let mos = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
    let res = new Set()
    // 第一层循环遍历 `单词数组` 拿到 `单词元素 word`
    words.forEach(word => {
        let mosStr = ''
        for (let i = 0; i < word.length; i++) {
            // 因为都是 `小写字母` ， `小写字母` 第一位 a 的数值编号是 97；
            // 我们需要从 `摩斯数组` 中，取 a 以及其后的字母对应的摩斯码
            // 就要使用字母的数值编号 - 97，得到摩斯数组中对应的下标
            let strNum = word[i].charCodeAt()
            // 变量 mosStr 拼接，得到该单词元素的 `摩斯码`
            mosStr += mos[strNum - 97]
        }
        // 因为集合唯一性的特性，确保每个元素都不重复，所以 res 的 size 就是最终的答案
        res.add(mosStr)
    })
    return res.size
};
```
<br>