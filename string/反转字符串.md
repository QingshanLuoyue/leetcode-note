## 反转字符串

**小提示：到现在，做了十几道算法题，发展算法要简洁快速，要善于使用 `while`**

<br>

### 题目
> 编写一个函数，其作用是将输入的字符串反转过来。<br>
输入字符串以字符数组 char[] 的形式给出。

>不要给另外的数组分配额外的空间<br>
你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

<br>

### 示例
```
示例 1：

输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

```
示例 2：

输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-string<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

<br>

### 解题思路
```javascript
1、初始计算
`字符串数组` 的长度的一半 `half`
`字符串数组` 的长度是否为奇数 `odd`
交换位置从 `字符串数组` 尾部开始，得到 `j` =  `字符串数组` 长度 - 1

2、循环 `字符串数组` ，首部从 `0` 开始，交换首尾位置，前后位置不断靠近交换

3、
3、1
若字符数组长度为 `奇数` ，且交换下标 `小于等于` 字符数组长度的一半 `half` ，即可跳出
例如：0 1 2 3 4 --- j 必须 `小于等于` 2，处于中间位置，不用操

3、2
若字符数组长度为 `偶数` ，且交换下标 `小于` 字符数组长度的一半 `half` ，即可跳出
例如：0 1 2 3 --- j 必须 `小于` 2，等于 2 的时候还要再交换一次
```

或者

较好力扣题解
```javascript
1、循环 `字符串数组`，i 为首部交换位，j 为尾部交换位

2、使用 ES 新特性交换位置
[a, b] = [b, a]

3、使用 while 循环
判断 `i <= j` 说明还没交换完成，继续循环交换
否则交换完成，跳出
```
<br>

### 题解
```javascript
let reverseString = function(s) {
    let temp = 0 // 用于交换的临时变量
    let j = s.length - 1 // 交换下标的初始位置
    let odd = s.length % 2 // 字符数组长度是否为奇数
    let half = Math.floor(s.length / 2) // 字符数组长度的一半
    for (let i = 0; i < s.length; i++) {
        // 循环字符数组，交换首尾位置，前后位置不断靠近交换
        temp = s[j]
        s[j] = s[i] // i 位置的值，赋值给 j 位
        s[i] = temp // i 的值为之前暂存起来的 j 位值
        j--
        // console.log('s :', s);
        if ((odd && j <= half) || (!odd && j < half)) {
            // 0 1 2 3 4 --- j 必须 小于等于 2，处于中间位置，不用操作
            // 若字符数组长度为 `奇数` ，且交换下标 `小于等于` 字符数组长度的一半
            // 即可跳出
            
            // 或者
            // 0 1 2 3 --- j 必须 小于 2，等于 2 的时候还要再交换一次
            // 若字符数组长度为 `偶数` ，且交换下标 `小于` 字符数组长度的一半
            // 即可跳出
            break
        }
    }
    return s
}
```

或者

较好力扣题解
```javascript
let reverseString = function(s) {
    let i = 0, j = s.length - 1
    // 使用 ES 新特性交换位置
    // [a, b] = [b, a]
    while (i <= j) {
        [s[i], s[j]] = [s[j], s[i]]
        // 交换完成后，前交换位 +1，后交换位 -1
        // 直到 前交换位 大于 后交换位，说明交换完成 
        i++
        j--
    }
    return s
}
```

<br>